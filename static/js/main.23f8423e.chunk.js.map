{"version":3,"sources":["logo.svg","Logic/Drawer.js","Logic/Prediction/Prediction.js","App.js","serviceWorker.js","index.js"],"names":["module","exports","__webpack_require__","p","DataFactory","n3","namedNode","literal","defaultGraph","quad","Component","Prediction","props","_this","Object","classCallCheck","this","possibleConstructorReturn","getPrototypeOf","call","DATASET_URL","sg","SPEED","first","signalgroups","prevGatGreen","lastGat","iLastGat","nextLastGat","AMOUNT_OF_FRAGMENTS","vertreklanen","data","lanes","state","laneValues","_store","getQuads","forEach","push","subject","value","_url","Promise","resolve","fetch","then","response","text","_doc","parser","Parser","store","Store","parse","error","prefixes","addQuad","node","console","log","download","doc","parseAndStoreQuads","getSignalgroups","_this2","analise","start","react_default","a","createElement","className","App","Logic_Prediction_Prediction","Boolean","window","location","hostname","match","ReactDOM","render","src_App_0","document","getElementById","navigator","serviceWorker","ready","registration","unregister"],"mappings":"yIAAAA,EAAAC,QAAiBC,EAAAC,EAAuB,gSCKhCC,EAAgBC,IAAhBD,YACAE,EAA2CF,EAA3CE,UCCAF,GDD2CA,EAAhCG,QAAgCH,EAAvBI,aAAuBJ,EAATK,KAErBC,YCDGL,IAAhBD,aACAE,EAA2CF,EAA3CE,UAkGOK,GAlGoCP,EAAhCG,QAAgCH,EAAvBI,aAAuBJ,EAATK,iBAItC,SAAAE,EAAYC,GAAM,IAAAC,EAAA,OAAAC,OAAAC,EAAA,EAAAD,CAAAE,KAAAL,IACdE,EAAAC,OAAAG,EAAA,EAAAH,CAAAE,KAAAF,OAAAI,EAAA,EAAAJ,CAAAH,GAAAQ,KAAAH,KAAMJ,KACDQ,YAAc,qDACnBP,EAAKQ,GAAK,sDACVR,EAAKS,MAAQ,EACbT,EAAKU,OAAQ,EACbV,EAAKW,aAAe,GACpBX,EAAKY,aAAe,GACpBZ,EAAKa,QAAU,KACfb,EAAKc,SAAW,KAChBd,EAAKe,YAAc,KACnBf,EAAKgB,oBAAsB,GAE3BhB,EAAKiB,aAAe,GACpBjB,EAAKkB,KAAO,GAEZlB,EAAKmB,MAAQ,GAEbnB,EAAKoB,MAAQ,CACTC,WAAY,IAnBFrB,uHAwBIsB,gFACdX,EAAe,YACbW,EAAOC,SAAS,KAAM9B,EAAU,6CAA8CA,EAAU,mDAAmD+B,QAAS,SAAC5B,GACvJe,EAAac,KAAK7B,EAAK8B,QAAQC,yCAE5BhB,uIAGFiB,GACL,OAAO,IAAIC,QAAQ,SAAAC,GACfC,MAAMH,GACDI,KAAK,SAASC,GACX,OAAOA,EAASC,SAEnBF,KAAK,SAASE,GACXJ,EAAQI,kDAKLC,GACf,OAAO,IAAIN,QAAQ,SAAAC,GACf,IAAMM,EAAS,IAAI5C,IAAG6C,OAChBC,EAAQ9C,IAAG+C,QACjBH,EAAOI,MAAML,EAAM,SAACM,EAAO7C,EAAM8C,GAC7B,IAAI9C,EAGA,OAAOkC,EAAQQ,GAFfA,EAAMK,QAAQ/C,uCAQtB0B,GACJA,EAAOC,SAAS,KAAM9B,EAAU,iDAAkD,MAAM+B,QAAQ,SAACoB,GAC7FC,QAAQC,IAAIF,mKAMhBC,QAAQC,IAAI,gCACI3C,KAAK4C,SAAS5C,KAAKI,2BAA/ByC,kBACc7C,KAAK8C,mBAAmBD,iBAAtCV,kBACsBnC,KAAK+C,gBAAgBZ,UAA/CnC,KAAKQ,oBAELR,KAAKQ,aAAaa,QAAQ,SAAChB,GACvB2C,EAAKvC,aAAaJ,GAAM,KACxB2C,EAAKjC,KAAKV,GAAM,KAGpBL,KAAKiD,QAAQd,kJAKbO,QAAQC,IAAI,qBACZ3C,KAAKkD,yCAIL,OACIC,EAAAC,EAAAC,cAAA,OAAKC,UAAU,UACXH,EAAAC,EAAAC,cAAA,+BA1FS3D,cCUV6D,mLAZX,OACEJ,EAAAC,EAAAC,cAAA,OAAKC,UAAU,OACbH,EAAAC,EAAAC,cAAA,UAAQC,UAAU,cAGhBH,EAAAC,EAAAC,cAACG,EAAD,eAPQ9D,aCME+D,QACW,cAA7BC,OAAOC,SAASC,UAEe,UAA7BF,OAAOC,SAASC,UAEhBF,OAAOC,SAASC,SAASC,MACvB,2DCZNC,IAASC,OAAOZ,EAAAC,EAAAC,cAACW,EAAD,MAASC,SAASC,eAAe,SD2H3C,kBAAmBC,WACrBA,UAAUC,cAAcC,MAAMxC,KAAK,SAAAyC,GACjCA,EAAaC","file":"static/js/main.23f8423e.chunk.js","sourcesContent":["module.exports = __webpack_public_path__ + \"static/media/logo.ee7cd8ed.svg\";","import React, { Component } from 'react';\r\nimport n3 from 'n3';\r\nimport { Table } from \"semantic-ui-react\";\r\n\r\n\r\nconst { DataFactory } = n3;\r\nconst { namedNode, literal, defaultGraph, quad } = DataFactory;\r\n\r\nclass Drawer extends Component {\r\n\r\n    constructor(props){\r\n        super(props);\r\n        this.DATASET_URL = 'https://lodi.ilabt.imec.be/observer/rawdata/latest';\r\n        this.sg = 'https://opentrafficlights.org/id/signalgroup/K648/1';\r\n        this.SPEED = 0;\r\n        this.first = true;\r\n        this.signalgroups = [];\r\n        this.prevGatGreen = [];\r\n        this.lastGat = null;\r\n        this.iLastGat = null;\r\n        this.nextLastGat = null;\r\n        this.AMOUNT_OF_FRAGMENTS = 15;\r\n\r\n        this.vertreklanen = {};\r\n        this.data = {};\r\n\r\n        this.lanes = {};    // hash to translate id to description\r\n\r\n        this.state = {\r\n            laneValues: {}, //contains the\r\n        };\r\n\r\n    }\r\n\r\n    sleep(milliseconds){\r\n        return new Promise(resolve => setTimeout(resolve, milliseconds))\r\n    }\r\n\r\n    initConfiguration(_store){\r\n        console.log(\"initConfiguration\");\r\n        let laneValues = {};\r\n        _store.getQuads(null, namedNode('https://w3id.org/opentrafficlights#departureLane'), null).forEach((quad) => {\r\n            _store.getQuads(quad.object, namedNode('http://purl.org/dc/terms/description'), null).forEach( (quad) => {\r\n                _store.getQuads(null, namedNode('https://w3id.org/opentrafficlights#departureLane'), quad.subject).forEach((connectie) => {\r\n                    let signalgroup = _store.getQuads(connectie.subject, namedNode('https://w3id.org/opentrafficlights#signalGroup'), null)[0].object.value;        //why 0 ?\r\n                    console.log(\"signalGroup\");\r\n                    let test = _store.getQuads(connectie.subject, namedNode('https://w3id.org/opentrafficlights#signalGroup'), null)[0].object.value;\r\n                    console.log(test);\r\n                    _store.getQuads(connectie.subject, namedNode('https://w3id.org/opentrafficlights#arrivalLane'), null).forEach( (arrivalLane) => {\r\n                        _store.getQuads(arrivalLane.object, namedNode('http://purl.org/dc/terms/description'), null).forEach( (descr) => {\r\n                            if(!this.vertreklanen[quad.subject.value]) this.vertreklanen[quad.subject.value] = [];\r\n                            this.vertreklanen[quad.subject.value][arrivalLane.object.value] = {\r\n                                '@id': arrivalLane.object.value,\r\n                                'http://purl.org/dc/terms/description': descr.object.value,\r\n                                'https://w3id.org/opentrafficlights#signalGroup': signalgroup       // why?\r\n                            };\r\n                            if(!laneValues[quad.subject.value]) laneValues[quad.subject.value] = {};\r\n                            laneValues[quad.subject.value][arrivalLane.object.value] = [\"initial\",\"initial\"];\r\n                            if(!this.lanes[arrivalLane.object.value]){\r\n                                this.lanes[arrivalLane.object.value] = descr.object.value;\r\n                            }\r\n                        });\r\n                    });\r\n\r\n                    if(!this.lanes[quad.subject.value]){\r\n                        this.lanes[quad.subject.value] = quad.object.value;\r\n                    }\r\n\r\n                });\r\n            });\r\n        });\r\n        //console.log(laneValues);\r\n        this.setState({lanes: this.vertreklanen, laneValues: laneValues});\r\n        //console.log(this.vertreklanen);\r\n    }\r\n\r\n    async getSignalgroups(_store) {\r\n        let signalgroups = [];\r\n        await _store.getQuads(null, namedNode('http://www.w3.org/2000/01/rdf-schema#type'), namedNode('https://w3id.org/opentrafficlights#Signalgroup')).forEach( (quad) => {\r\n            signalgroups.push(quad.subject.value);\r\n        });\r\n        return signalgroups;\r\n    }\r\n\r\n    download(_url) {\r\n        return new Promise(resolve => {\r\n            fetch(_url)\r\n                .then(function(response) {\r\n                    return response.text();\r\n                })\r\n                .then(function(text) {\r\n                    resolve(text);\r\n                });\r\n        });\r\n    }\r\n\r\n    parseAndStoreQuads(_doc) {\r\n        return new Promise(resolve => {\r\n            const parser = new n3.Parser();\r\n            const store = n3.Store();\r\n            parser.parse(_doc, (error, quad, prefixes) => {\r\n                if (quad)\r\n                    store.addQuad(quad);\r\n                else\r\n                    return resolve(store);\r\n            });\r\n        })\r\n    }\r\n\r\n    async calcHistoricData(_store) {\r\n        // Loop over observations order descending\r\n        let observations = _store.getQuads(null, namedNode('http://www.w3.org/ns/prov#generatedAtTime'), null);\r\n        observations.sort(function(a, b) {\r\n            a = new Date(a.object.value).getTime();\r\n            b = new Date(b.object.value).getTime();\r\n\r\n            return a>b ? -1 : a<b ? 1 : 0;\r\n        }).forEach((observation) => {\r\n            let generatedAtTime = new Date(observation.object.value);\r\n\r\n            if(generatedAtTime !== this.lastGat){\r\n                //console.log(new Date() - generatedAtTime);\r\n                //console.log(generatedAtTime);\r\n                this.lastGat = generatedAtTime;\r\n            }\r\n\r\n            // Loop over all signalstates in the observation\r\n            _store.getQuads(null, namedNode('https://w3id.org/opentrafficlights#signalState'), null, observation.subject).forEach((signalstateQuad) => {\r\n                let signalgroup = signalstateQuad.subject.value;\r\n                let signalphase = _store.getQuads(signalstateQuad.object, namedNode('https://w3id.org/opentrafficlights#signalPhase'), null, observation.subject)[0];\r\n                let timeTillGreen;\r\n                // When green\r\n                if (signalphase.object.value === 'https://w3id.org/opentrafficlights/thesauri/signalphase/6') {\r\n                    this.prevGatGreen[signalgroup] = generatedAtTime;\r\n                    timeTillGreen = 0;\r\n                }\r\n\r\n                if (this.prevGatGreen[signalgroup] != null){ //does not work with !==\r\n                    timeTillGreen = (this.prevGatGreen[signalgroup].getTime() - generatedAtTime.getTime())/1000;\r\n\r\n                    // There's probably a data gap when this is very big\r\n                    if (timeTillGreen < 100) {\r\n                        if (!this.data[signalgroup]) this.data[signalgroup] = [];\r\n\r\n                        this.data[signalgroup].unshift({\r\n                            'generatedAtTime': new Date(generatedAtTime),\r\n                            'timeTillGreen': timeTillGreen\r\n                        })\r\n                    }\r\n                }\r\n            });\r\n        });\r\n    }\r\n\r\n    async start() {\r\n        console.log(\"async funtion start\");\r\n        let doc = await this.download(this.DATASET_URL);\r\n        let store = await this.parseAndStoreQuads(doc);\r\n        this.signalgroups = await this.getSignalgroups(store);\r\n        this.initConfiguration(store);\r\n\r\n        // Init\r\n        this.signalgroups.forEach((sg) => {\r\n            this.prevGatGreen[sg] = null;\r\n            this.data[sg] = [];\r\n        });\r\n\r\n        while(true) {\r\n            await this.calcHistoricData(store);\r\n            this.showLatest(store);\r\n\r\n            let count = 0;\r\n\r\n            // HISTORY\r\n            let prev = store.getQuads(null, namedNode('http://www.w3.org/ns/hydra/core#previous'), null)[0];\r\n            while (prev && count < this.AMOUNT_OF_FRAGMENTS) {\r\n                count++;\r\n\r\n                doc = await this.download(prev.object.value);\r\n                store = await this.parseAndStoreQuads(doc);\r\n\r\n                await this.calcHistoricData(store);\r\n\r\n                prev = store.getQuads(null, namedNode('http://www.w3.org/ns/hydra/core#previous'), null)[0];\r\n            }\r\n\r\n            doc = await this.download(this.DATASET_URL);\r\n            store = await this.parseAndStoreQuads(doc);\r\n\r\n            this.signalgroups.forEach((sg) => {\r\n                this.prevGatGreen[sg] = null;\r\n                this.data[sg] = [];\r\n            });\r\n\r\n            await this.sleep(this.SPEED)\r\n        }\r\n    }\r\n\r\n    async showLatest(_store) {\r\n        // Loop over observations order descending\r\n        let observations = _store.getQuads(null, namedNode('http://www.w3.org/ns/prov#generatedAtTime'), null);\r\n        //console.log(\"observations: \");\r\n        //console.log(observations);\r\n        let latest = observations.sort(function(a, b) {\r\n            a = new Date(a.object.value).getTime();\r\n            b = new Date(b.object.value).getTime();\r\n\r\n            return a>b ? -1 : a<b ? 1 : 0;\r\n        })[0];\r\n\r\n        let generatedAtTime = latest.object.value;\r\n        //console.log(\"latest: \");\r\n        //console.log(latest);\r\n\r\n        let doc = this;\r\n        let laneValues = this.state.laneValues;\r\n        Object.keys(this.vertreklanen).forEach(\r\n            function (fromLane) {\r\n                Object.keys(doc.vertreklanen[fromLane]).forEach(\r\n                    function (toLane) {\r\n                        let signal = doc.vertreklanen[fromLane][toLane]['https://w3id.org/opentrafficlights#signalGroup'];\r\n                        // Get state of active signalgroup\r\n                        //console.log(signal);\r\n                        //console.log(this.sg);\r\n                        let signalstate = _store.getQuads(namedNode(signal), namedNode('https://w3id.org/opentrafficlights#signalState'), null, latest.subject)[0];\r\n                        if (signalstate) {\r\n                            let minEndTime = _store.getQuads(signalstate.object, namedNode('https://w3id.org/opentrafficlights#minEndTime'), null, latest.subject)[0];\r\n                            let maxEndTime = _store.getQuads(signalstate.object, namedNode('https://w3id.org/opentrafficlights#maxEndTime'), null, latest.subject)[0];\r\n                            let signalPhase = _store.getQuads(signalstate.object, namedNode('https://w3id.org/opentrafficlights#signalPhase'), null, latest.subject)[0];\r\n\r\n                            let count = Math.round((new Date(minEndTime.object.value).getTime() - new Date(generatedAtTime).getTime())/1000);\r\n                            if (minEndTime.object.value === maxEndTime.object.value) {\r\n                                laneValues[fromLane][toLane] = [count, signalPhase.object.value];\r\n                                //this.showCounterLabel(count, signalPhase.object.value);\r\n                            } else {\r\n                                laneValues[fromLane][toLane] = [\">\" + count, signalPhase.object.value];\r\n                                //this.showCounterLabel(\"> \" + count, signalPhase.object.value);\r\n                            }\r\n                        }\r\n\r\n                    }\r\n                )\r\n\r\n            }\r\n        );\r\n\r\n        this.setState({\r\n            laneValues: laneValues,\r\n        })\r\n\r\n    }\r\n\r\n    showCounterLabel(counter_, label_) {\r\n        const info = '<h3>' + counter_ + \" seconden</h3>\";\r\n\r\n        // const info = '<h3 style=\"float: left\">' + label_ + '</h3><h1 style=\"font-size: 100px;\">' + counter_ + '</h1></div>';\r\n        if (label_ === 'https://w3id.org/opentrafficlights/thesauri/signalphase/2' || label_ === 'https://w3id.org/opentrafficlights/thesauri/signalphase/3') {\r\n            // Red\r\n\r\n        }\r\n        else if (label_ === 'https://w3id.org/opentrafficlights/thesauri/signalphase/5' || label_ === 'https://w3id.org/opentrafficlights/thesauri/signalphase/6') {\r\n            // green\r\n        }\r\n        else {\r\n            // orange\r\n        }\r\n        return info;\r\n    }\r\n\r\n    componentDidMount(){\r\n        console.log(\"componentDidMount\");\r\n        this.start();\r\n    }\r\n\r\n    buildTable(){\r\n        let table = \"<Table>\";\r\n        this.vertreklanen.forEach(function (fromLane) {\r\n            table += \"<Table.Row>\";\r\n            table += \"<Table.HeaderCell>\" + fromLane + \"</Table.HeaderCell>\";\r\n            this.vertreklanen[fromLane].forEach(function (toLane) {\r\n                table += \"<Table.Cell>\" + toLane + \"</Table.Cell>\";\r\n            });\r\n            table += \"</Table.Row>\";\r\n        });\r\n        table += \"</Table>\";\r\n        return table;\r\n    }\r\n\r\n    render() {\r\n        console.log(\"render\");\r\n        const {laneValues} = this.state;\r\n        //console.log(this.vertreklanen);\r\n        let doc = this;\r\n        return (\r\n            <div className=\"Drawer\">\r\n                <Table>\r\n                    <Table.Header>\r\n                        <Table.Row>\r\n                            <Table.HeaderCell>From Lane:</Table.HeaderCell>\r\n                            <Table.HeaderCell>To Lanes:</Table.HeaderCell>\r\n                        </Table.Row>\r\n                    </Table.Header>\r\n                    <Table.Body>\r\n                        {Object.keys(this.vertreklanen).map(\r\n                            function (fromLane) {\r\n                                // console.log(\"from: \" + fromLane);\r\n                                return (\r\n                                    <Table.Row><Table.Cell>{fromLane}:{doc.lanes[fromLane]}</Table.Cell>{Object.keys(doc.vertreklanen[fromLane]).map(\r\n                                        function (toLane) {\r\n                                            //console.log(\"to: \" + toLane);\r\n                                            //console.log(\"lanevalues\");\r\n                                            //console.log(laneValues);\r\n                                            const label_= laneValues[fromLane][toLane] ? laneValues[fromLane][toLane][1] : \"fail\";\r\n                                            const count = laneValues[fromLane][toLane] ? laneValues[fromLane][toLane][0] : \"fail\";\r\n                                            if (label_ === 'https://w3id.org/opentrafficlights/thesauri/signalphase/2' || label_ === 'https://w3id.org/opentrafficlights/thesauri/signalphase/3') {\r\n                                                // Red\r\n                                                return (<Table.Cell>{toLane}:{doc.lanes[toLane]}<p style={{color: 'red'}}>{count}</p></Table.Cell>);\r\n                                            }\r\n                                            else if (label_ === 'https://w3id.org/opentrafficlights/thesauri/signalphase/5' || label_ === 'https://w3id.org/opentrafficlights/thesauri/signalphase/6') {\r\n                                                // green\r\n                                                return (<Table.Cell>{toLane}:{doc.lanes[toLane]}<p style={{color: 'green'}}>{count}</p></Table.Cell>);\r\n                                            }\r\n                                            else {\r\n                                                // orange\r\n                                                return (<Table.Cell>{toLane}:{doc.lanes[toLane]}<p style={{ color: 'orange'}}>{count}</p></Table.Cell>);\r\n                                            }\r\n                                        })\r\n                                    }</Table.Row>);\r\n                            }\r\n                        )}\r\n                    </Table.Body>\r\n                </Table>\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\nexport default Drawer;","\r\n\r\nimport React, { Component } from 'react';\r\nimport n3 from 'n3';\r\nimport { Table } from \"semantic-ui-react\";\r\n\r\n\r\nconst { DataFactory } = n3;\r\nconst { namedNode, literal, defaultGraph, quad } = DataFactory;\r\n\r\nclass Prediction extends Component {\r\n\r\n    constructor(props){\r\n        super(props);\r\n        this.DATASET_URL = 'https://lodi.ilabt.imec.be/observer/rawdata/latest';\r\n        this.sg = 'https://opentrafficlights.org/id/signalgroup/K648/1';\r\n        this.SPEED = 0;\r\n        this.first = true;\r\n        this.signalgroups = [];\r\n        this.prevGatGreen = [];\r\n        this.lastGat = null;\r\n        this.iLastGat = null;\r\n        this.nextLastGat = null;\r\n        this.AMOUNT_OF_FRAGMENTS = 15;\r\n\r\n        this.vertreklanen = {};\r\n        this.data = {};\r\n\r\n        this.lanes = {};    // hash to translate id to description\r\n\r\n        this.state = {\r\n            laneValues: {}, //contains the\r\n        };\r\n\r\n    }\r\n\r\n    async getSignalgroups(_store) {\r\n        let signalgroups = [];\r\n        await _store.getQuads(null, namedNode('http://www.w3.org/2000/01/rdf-schema#type'), namedNode('https://w3id.org/opentrafficlights#Signalgroup')).forEach( (quad) => {\r\n            signalgroups.push(quad.subject.value);\r\n        });\r\n        return signalgroups;\r\n    }\r\n\r\n    download(_url) {\r\n        return new Promise(resolve => {\r\n            fetch(_url)\r\n                .then(function(response) {\r\n                    return response.text();\r\n                })\r\n                .then(function(text) {\r\n                    resolve(text);\r\n                });\r\n        });\r\n    }\r\n\r\n    parseAndStoreQuads(_doc) {\r\n        return new Promise(resolve => {\r\n            const parser = new n3.Parser();\r\n            const store = n3.Store();\r\n            parser.parse(_doc, (error, quad, prefixes) => {\r\n                if (quad)\r\n                    store.addQuad(quad);\r\n                else\r\n                    return resolve(store);\r\n            });\r\n        })\r\n    }\r\n\r\n\r\n    analise(_store){\r\n        _store.getQuads(null, namedNode('https://w3id.org/opentrafficlights#minEndTime'), null).forEach((node) => {\r\n            console.log(node);\r\n        });\r\n\r\n    }\r\n\r\n    async start() {\r\n        console.log(\"async funtion start\");\r\n        let doc = await this.download(this.DATASET_URL);\r\n        let store = await this.parseAndStoreQuads(doc);\r\n        this.signalgroups = await this.getSignalgroups(store);\r\n        // Init\r\n        this.signalgroups.forEach((sg) => {\r\n            this.prevGatGreen[sg] = null;\r\n            this.data[sg] = [];\r\n        });\r\n\r\n        this.analise(store);\r\n\r\n    }\r\n\r\n    componentDidMount(){\r\n        console.log(\"componentDidMount\");\r\n        this.start();\r\n    }\r\n\r\n    render() {\r\n        return (\r\n            <div className=\"Drawer\">\r\n                <p>prediction</p>\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\nexport default Prediction;\r\n\r\n","import React, { Component } from 'react';\r\nimport logo from './logo.svg';\r\nimport './App.css';\r\nimport Drawer from \"./Logic/Drawer\";\r\nimport Prediction from \"./Logic/Prediction/Prediction\";\r\n\r\nclass App extends Component {\r\n  render() {\r\n    return (\r\n      <div className=\"App\">\r\n        <header className=\"App-header\">\r\n          {/*<img src={logo} className=\"App-logo\" alt=\"logo\" />*/}\r\n          {/*<Drawer/>*/}\r\n          <Prediction/>\r\n        </header>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nexport default App;\r\n","// This optional code is used to register a service worker.\r\n// register() is not called by default.\r\n\r\n// This lets the app load faster on subsequent visits in production, and gives\r\n// it offline capabilities. However, it also means that developers (and users)\r\n// will only see deployed updates on subsequent visits to a page, after all the\r\n// existing tabs open on the page have been closed, since previously cached\r\n// resources are updated in the background.\r\n\r\n// To learn more about the benefits of this model and instructions on how to\r\n// opt-in, read http://bit.ly/CRA-PWA\r\n\r\nconst isLocalhost = Boolean(\r\n  window.location.hostname === 'localhost' ||\r\n    // [::1] is the IPv6 localhost address.\r\n    window.location.hostname === '[::1]' ||\r\n    // 127.0.0.1/8 is considered localhost for IPv4.\r\n    window.location.hostname.match(\r\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\r\n    )\r\n);\r\n\r\nexport function register(config) {\r\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\r\n    // The URL constructor is available in all browsers that support SW.\r\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\r\n    if (publicUrl.origin !== window.location.origin) {\r\n      // Our service worker won't work if PUBLIC_URL is on a different origin\r\n      // from what our page is served on. This might happen if a CDN is used to\r\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\r\n      return;\r\n    }\r\n\r\n    window.addEventListener('load', () => {\r\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\r\n\r\n      if (isLocalhost) {\r\n        // This is running on localhost. Let's check if a service worker still exists or not.\r\n        checkValidServiceWorker(swUrl, config);\r\n\r\n        // Add some additional logging to localhost, pointing developers to the\r\n        // service worker/PWA documentation.\r\n        navigator.serviceWorker.ready.then(() => {\r\n          console.log(\r\n            'This web app is being served cache-first by a service ' +\r\n              'worker. To learn more, visit http://bit.ly/CRA-PWA'\r\n          );\r\n        });\r\n      } else {\r\n        // Is not localhost. Just register service worker\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nfunction registerValidSW(swUrl, config) {\r\n  navigator.serviceWorker\r\n    .register(swUrl)\r\n    .then(registration => {\r\n      registration.onupdatefound = () => {\r\n        const installingWorker = registration.installing;\r\n        if (installingWorker == null) {\r\n          return;\r\n        }\r\n        installingWorker.onstatechange = () => {\r\n          if (installingWorker.state === 'installed') {\r\n            if (navigator.serviceWorker.controller) {\r\n              // At this point, the updated precached content has been fetched,\r\n              // but the previous service worker will still serve the older\r\n              // content until all client tabs are closed.\r\n              console.log(\r\n                'New content is available and will be used when all ' +\r\n                  'tabs for this page are closed. See http://bit.ly/CRA-PWA.'\r\n              );\r\n\r\n              // Execute callback\r\n              if (config && config.onUpdate) {\r\n                config.onUpdate(registration);\r\n              }\r\n            } else {\r\n              // At this point, everything has been precached.\r\n              // It's the perfect time to display a\r\n              // \"Content is cached for offline use.\" message.\r\n              console.log('Content is cached for offline use.');\r\n\r\n              // Execute callback\r\n              if (config && config.onSuccess) {\r\n                config.onSuccess(registration);\r\n              }\r\n            }\r\n          }\r\n        };\r\n      };\r\n    })\r\n    .catch(error => {\r\n      console.error('Error during service worker registration:', error);\r\n    });\r\n}\r\n\r\nfunction checkValidServiceWorker(swUrl, config) {\r\n  // Check if the service worker can be found. If it can't reload the page.\r\n  fetch(swUrl)\r\n    .then(response => {\r\n      // Ensure service worker exists, and that we really are getting a JS file.\r\n      const contentType = response.headers.get('content-type');\r\n      if (\r\n        response.status === 404 ||\r\n        (contentType != null && contentType.indexOf('javascript') === -1)\r\n      ) {\r\n        // No service worker found. Probably a different app. Reload the page.\r\n        navigator.serviceWorker.ready.then(registration => {\r\n          registration.unregister().then(() => {\r\n            window.location.reload();\r\n          });\r\n        });\r\n      } else {\r\n        // Service worker found. Proceed as normal.\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    })\r\n    .catch(() => {\r\n      console.log(\r\n        'No internet connection found. App is running in offline mode.'\r\n      );\r\n    });\r\n}\r\n\r\nexport function unregister() {\r\n  if ('serviceWorker' in navigator) {\r\n    navigator.serviceWorker.ready.then(registration => {\r\n      registration.unregister();\r\n    });\r\n  }\r\n}\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport App from './App';\r\nimport * as serviceWorker from './serviceWorker';\r\n\r\nReactDOM.render(<App />, document.getElementById('root'));\r\n\r\n// If you want your app to work offline and load faster, you can change\r\n// unregister() to register() below. Note this comes with some pitfalls.\r\n// Learn more about service workers: http://bit.ly/CRA-PWA\r\nserviceWorker.unregister();\r\n"],"sourceRoot":""}